<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Luxury Tree - Ultimate Edition</title>
     
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Ma+Shan+Zheng&display=swap');
 
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Cinzel', serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
         
        #ui-layer { position: absolute; width: 100%; height: 100%; z-index: 10; pointer-events: none; background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.3) 100%); }
         
        #main-title {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
            font-family: 'Cinzel', serif;
            font-weight: 800;
            font-size: clamp(36px, 7vw, 80px); 
            letter-spacing: 0.15em;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            min-height: 1.2em;
             
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-image: linear-gradient(180deg, #fffdf0 0%, #eacda3 30%, #d6ae7b 60%, #8b6c42 100%);
            filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.6));
             
            animation: titleFadeIn 2s ease-out forwards 1s;
            transition: filter 1.5s ease, background-image 1.5s ease;
        }
 
        @keyframes titleFadeIn {
            from { opacity: 0; transform: translate(-50%, -20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
 
        #loader { position: absolute; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; align-items: center; justify-content: center; transition: opacity 1.2s; pointer-events: none; }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.1); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
 
        #top-right-controls { position: absolute; top: 20px; right: 20px; z-index: 30; display: flex; flex-direction: row; gap: 15px; pointer-events: auto; }
        .control-col { display: flex; flex-direction: column; gap: 15px; }
         
        .control-btn { background: rgba(10, 10, 10, 0.6); border: 1px solid rgba(212, 175, 55, 0.4); color: #d4af37; width: 100px; padding: 5px 0; border-radius: 7px; font-family: 'Cinzel', serif; font-size: 14px; font-weight: 600; cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s ease; }
        .control-btn:hover { background: rgba(212, 175, 55, 0.2); border-color: rgba(212, 175, 55, 0.8); color: #fff; transform: scale(1.05); }
        .control-btn:active { transform: scale(0.95); }
        .control-btn.disabled { color: #666; border-color: #444; }
         
        #file-input, #music-input, #import-input { display: none; }
 
        #webcam-wrapper { position: absolute; bottom: 20px; right: 20px; opacity: 0; pointer-events: none; border: 1px solid rgba(212, 175, 55, 0.5); border-radius: 4px; background: #000; z-index: 50; display: flex; transition: opacity 0.5s; }
        #webcam { display: none; }
        #webcam-preview { width: 100%; height: 100%; transform: scaleX(-1); }

        #gesture-hud {
            position: absolute; bottom: 150px; right: 20px; width: 160px;
            background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 5px; color: #fff; padding: 10px; font-size: 12px;
            pointer-events: none; z-index: 40; opacity: 0; transition: opacity 0.5s;
            text-align: right; backdrop-filter: blur(3px);
        }
        #gesture-hud span { color: #d4af37; font-weight: bold; }
 
        #letter-editor-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 500px; background: rgba(10, 10, 10, 0.95); border: 1px solid #d4af37; border-radius: 10px; padding: 20px; z-index: 200; display: none; flex-direction: column; gap: 15px; pointer-events: auto; }
        #letter-editor-modal h3 { color: #d4af37; margin: 0; text-align: center; }
        #letter-text-input { width: 100%; height: 150px; background: rgba(255,255,255,0.05); border: 1px solid #444; color: #fff; padding: 10px; resize: none; outline: none; }
        .modal-btn-group { display: flex; justify-content: flex-end; gap: 10px; }
 
        #letter-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 150; background: rgba(0,0,0,0.4); display: none; align-items: center; justify-content: center; pointer-events: auto; opacity: 0; transition: opacity 1.5s ease; }
        .letter-paper { height: 80%; aspect-ratio: 3/4; background: rgba(255, 252, 240, 0.15); backdrop-filter: blur(3px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 6vh; box-sizing: border-box; position: relative; display: flex; flex-direction: column; transform: translateY(20px); transition: transform 1.5s ease-out; }
        .letter-content { font-family: 'Ma Shan Zheng', cursive; font-size: clamp(16px, 2.5vh, 24px); line-height: 1.8; color: rgba(255, 255, 255, 0.9); text-shadow: 0 0 5px rgba(255,215,0, 0.3); white-space: pre-wrap; overflow-y: auto; flex: 1; scroll-behavior: smooth; }
         
        .letter-content::-webkit-scrollbar { width: 6px; }
        .letter-content::-webkit-scrollbar-thumb { background: rgba(212, 175, 55, 0.3); border-radius: 3px; }
        .cursor::after { content: '|'; animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }
 
        .letter-close-btn { position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.4); border-radius: 50%; color: rgba(255,255,255,0.7); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s; }
        .letter-close-btn:hover { background: rgba(255,255,255,0.2); color: #fff; border-color: #fff; }

        #interaction-hint {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; z-index: 15;
            text-align: center; opacity: 0; animation: fadeInOut 5s forwards 2s;
        }
        @keyframes fadeInOut { 0% { opacity:0; } 20% { opacity:1; } 80% { opacity:1; } 100% { opacity:0; } }

        /* 新增：错误提示 Toast */
        #error-toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 50, 50, 0.8); color: white; padding: 10px 20px;
            border-radius: 5px; font-size: 14px; z-index: 200; pointer-events: none;
            opacity: 0; transition: opacity 0.5s; text-align: center;
        }
    </style>
 
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
 
<body>
    <div id="loader"><div class="spinner"></div></div>
    <div id="canvas-container"></div>
    <div id="interaction-hint">拖拽旋转视角 • 滚轮散开粒子</div>
    <div id="error-toast"></div>
 
    <div id="ui-layer">
        <div id="main-title"></div>
 
        <div id="top-right-controls">
            <div class="control-col" id="col-media">
                <button id="btn-bg-music" class="control-btn">上传音乐</button>
                <button id="btn-add-photo" class="control-btn">上传照片</button>
                <button id="btn-write-letter" class="control-btn">上传书信</button>
                <button id="btn-set-title" class="control-btn">设置标题</button>
            </div>
            <div class="control-col" id="col-system">
                <button id="btn-import" class="control-btn">导入网页</button>
                <button id="btn-export" class="control-btn">导出网页</button>
                <button id="btn-fullscreen" class="control-btn">全屏显示</button>
                <button id="btn-switch-theme" class="control-btn">颜色切换</button>
            </div>
        </div>
        <input type="file" id="file-input" multiple accept="image/*">
        <input type="file" id="music-input" accept="audio/mp3,audio/*">
        <input type="file" id="import-input" accept=".json">
    </div>
 
    <div id="letter-editor-modal">
        <h3>撰写你的心意</h3>
        <textarea id="letter-text-input" placeholder="在这里写下你想说的话..."></textarea>
        <div class="modal-btn-group">
            <button id="btn-cancel-letter" class="control-btn" style="width: 80px;">取消</button>
            <button id="btn-save-letter" class="control-btn" style="width: 80px;">保存</button>
        </div>
    </div>
 
    <div id="letter-overlay">
        <div class="letter-paper">
            <div class="letter-close-btn" id="btn-close-letter-mode">×</div>
            <div class="letter-content" id="letter-content-display"></div>
        </div>
    </div>
 
    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline webkit-playsinline></video>
        <canvas id="webcam-preview"></canvas>
    </div>

    <div id="gesture-hud">
        状态: <span id="hud-status">等待识别...</span><br>
        动作: <span id="hud-action">-</span>
    </div>
     
    <audio id="bg-music" loop crossorigin="anonymous"></audio>
     
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';
 
        const CONFIG = {
            colors: {
                bg: 0x020205, gold: 0xffd700, red: 0x880000, green: 0x004400,
                iceBlue: 0xaaddff, iceCyan: 0x00ffff, iceMagenta: 0xff00cc,
                white: 0xffffff, barbieHot: 0xff1694, barbieSoft: 0xffb7c5
            },
            particles: { count: 1800, dustCount: 1500, treeHeight: 28, treeRadius: 9, snowCount: 2500, snowSpeed: 10 },
            camera: { z: 55 },
            gestures: { palmOpenThreshold: 0.35, sensitivity: 6.0 }
        };
 
        const STATE = {
            mode: 'TREE', focusTarget: null, currentPhotoIndex: -1, currentThemeIndex: 0, 
            gestureDebounceTimer: 0, isGestureSwitchEnabled: true, scatterScale: 1.0, gestureBaseSpread: null,
            hand: { detected: false, x: 0, y: 0 }, rotation: { x: 0, y: 0 }, spinVel: { x: 0, y: 0 }, time: 0,
            wasPointing: false, palmCenter: { x: 0.5, y: 0.5 }, hasPalmCenter: false,
            starMesh: null, starHaloMesh: null,
            letterContent: "", letterTyper: null, letterStartTimer: null, letterLastTriggerTime: 0, musicData: null,
            mouse: { isDragging: false, x: 0, y: 0, targetScatter: 1.0 },
            fireworks: []
        };
 
        let scene, camera, renderer, composer, clock = new THREE.Clock();
        let mainGroup, starGroup, bgGroup, photoMeshGroup, particleSystem = []; 
        let galaxySystem = null, snowSystem = null, heartSystem = null;
        let handLandmarker, video, drawingUtils, canvasCtx;
        let caneTexture, snowTexture, heartTexture, glowTexture, matLib = {}; // glowTexture added
         
        const _tempVec = new THREE.Vector3();
        const _targetVec = new THREE.Vector3();
        const _invMatrix = new THREE.Matrix4();
 
        async function init() {
            initThree();            
            setupEnvironment();     
            setupLights();          
            createTextures();       
            createMaterials(); 
             
            createGalaxyBackground(); 
            createSnowBackground();
            createHeartBackground();
             
            createParticles();      
            setupPostProcessing();
            setupEvents();          
            setupLetterSystem();
            setupMouseInteraction();
             
            switchTheme(0);
 
            // 尝试初始化 AI，如果失败则优雅降级
            try {
                await initMediaPipe();
            } catch (error) {
                console.warn("Mediapipe load failed (likely network issue), fallback to mouse mode.", error);
                showToast("⚠️ 网络原因，AI手势已禁用<br>请使用鼠标/触屏交互");
                document.getElementById('webcam-wrapper').style.display = 'none';
                document.getElementById('gesture-hud').style.display = 'none';
            }
 
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1200);
 
            animate(); 
        }

        function showToast(msg) {
            const el = document.getElementById('error-toast');
            el.innerHTML = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 5000);
        }
 
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012); 
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, CONFIG.camera.z); 
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", depth: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.0; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            bgGroup = new THREE.Group(); scene.add(bgGroup);
            mainGroup = new THREE.Group(); mainGroup.rotation.x = 0.1; scene.add(mainGroup);
            starGroup = new THREE.Group(); mainGroup.add(starGroup);
            photoMeshGroup = new THREE.Group(); mainGroup.add(photoMeshGroup);
        }
 
        function setupEnvironment() {
            const pmrem = new THREE.PMREMGenerator(renderer);
            pmrem.compileEquirectangularShader();
            scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
        }
 
        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 3, 40);
            bottomLight.position.set(0, -10, 10);
            mainGroup.add(bottomLight);
            const spotGold = new THREE.SpotLight(0xfff0dd, 800);
            spotGold.position.set(40, 60, 40); spotGold.angle = 0.4; spotGold.decay = 2;
            scene.add(spotGold);
            const spotBlue = new THREE.SpotLight(0x4455ff, 400);
            spotBlue.position.set(-40, 10, -30); spotBlue.lookAt(0,0,0);
            scene.add(spotBlue);
        }
 
        function setupPostProcessing() {
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.threshold = 0.75; bloom.strength = 0.5; bloom.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);
        }

        // 修复 404: 使用 Canvas 生成光晕贴图
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0, 32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }
 
        function createFrostTexture() {
            const canvas = document.createElement('canvas'); 
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#666'; ctx.fillRect(0,0,256,256);
            for(let i=0; i<80; i++) {
                ctx.strokeStyle = `rgba(255,255,255,${0.2 + Math.random()*0.5})`;
                ctx.lineWidth = Math.random() * 2 + 0.5;
                ctx.beginPath();
                const x = Math.random()*256, y = Math.random()*256;
                ctx.moveTo(x, y);
                ctx.lineTo(x + (Math.random()-0.5)*60, y + (Math.random()-0.5)*60);
                ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
 
        function createTextures() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#aa0000'; ctx.beginPath();
            for(let i=-128; i<256; i+=32) { ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0); }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.colorSpace = THREE.SRGBColorSpace;
            caneTexture.wrapS = THREE.RepeatWrapping; caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
 
            const snowCvs = document.createElement('canvas'); snowCvs.width = 32; snowCvs.height = 32;
            const sCtx = snowCvs.getContext('2d');
            const grad = sCtx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            sCtx.fillStyle = grad; sCtx.fillRect(0,0,32,32);
            snowTexture = new THREE.CanvasTexture(snowCvs);
 
            const hCvs = document.createElement('canvas'); hCvs.width = 64; hCvs.height = 64;
            const hCtx = hCvs.getContext('2d');
            hCtx.fillStyle = '#ffffff';
            hCtx.beginPath();
            hCtx.moveTo(32, 20);
            hCtx.bezierCurveTo(32, 17, 30, 10, 20, 10);
            hCtx.bezierCurveTo(10, 10, 10, 25, 10, 25);
            hCtx.bezierCurveTo(10, 35, 20, 42, 32, 55);
            hCtx.bezierCurveTo(44, 42, 54, 35, 54, 25);
            hCtx.bezierCurveTo(54, 25, 54, 10, 44, 10);
            hCtx.bezierCurveTo(36, 10, 32, 17, 32, 20);
            hCtx.fill();
            heartTexture = new THREE.CanvasTexture(hCvs);

            glowTexture = createGlowTexture(); // Initialize the fixed texture
        }
 
        function createMaterials() {
            matLib.gold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.15, envMapIntensity: 2.5, emissive: 0x664400, emissiveIntensity: 0.2 });
            matLib.green = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.4, roughness: 0.3, emissive: 0x001100, emissiveIntensity: 0.1 });
            matLib.red = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.6, roughness: 0.2, clearcoat: 1.0, emissive: 0x330000, emissiveIntensity: 0.4 });
            matLib.candy = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.3, metalness: 0.1, emissive: 0x222222 });
            matLib.starGold = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 2.0, metalness: 1.0, roughness: 0 });
            matLib.frameGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 });
            matLib.ice = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.95, thickness: 1.5, ior: 1.8, 
                clearcoat: 1.0, envMapIntensity: 2.0, iridescence: 1.0, iridescenceIOR: 1.3, emissive: CONFIG.colors.iceBlue, emissiveIntensity: 0.3 
            });
            matLib.frozenCyan = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.iceCyan, metalness: 0.8, roughness: 0.2, emissive: CONFIG.colors.iceCyan, emissiveIntensity: 2.0, clearcoat: 1.0 });
            matLib.frozenMagenta = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.iceMagenta, metalness: 0.5, roughness: 0.2, emissive: CONFIG.colors.iceMagenta, emissiveIntensity: 1.5, clearcoat: 1.0 });
            matLib.starIce = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.iceCyan, emissive: 0xffffff, emissiveIntensity: 3.0, metalness: 0.2, roughness: 0, transmission: 0.6, thickness: 3.0 });
            matLib.snow = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.8, emissive: 0xaaaaaa, emissiveIntensity: 0.8 });
            matLib.barbieMain = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.barbieHot, metalness: 0.2, roughness: 0.1, clearcoat: 1.0, emissive: 0x440022, emissiveIntensity: 0.3 });
            matLib.barbieSoft = new THREE.MeshStandardMaterial({ color: CONFIG.colors.barbieSoft, metalness: 0.1, roughness: 0.4, emissive: 0x442233, emissiveIntensity: 0.2 });
            matLib.pearl = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.9, roughness: 0.1, transmission: 0.1, clearcoat: 1.0, iridescence: 1.0, iridescenceIOR: 1.3 });
            matLib.starBarbie = new THREE.MeshStandardMaterial({ color: CONFIG.colors.barbieHot, emissive: 0xff0088, emissiveIntensity: 4.0, metalness: 0.5, roughness: 0.1 });
            matLib.frameBarbie = matLib.barbieMain;
            matLib.snowBorder = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.BackSide });
            matLib.frameIce = matLib.ice;
            matLib.dust = new THREE.MeshBasicMaterial({ color: 0xffffee, blending: THREE.AdditiveBlending });
            matLib.snowFlake = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, map: snowTexture, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false });
            matLib.heartFlake = new THREE.PointsMaterial({ color: CONFIG.colors.barbieHot, size: 1.5, map: heartTexture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
        }
 
        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh; this.type = type; this.isDust = isDust;
                this.posTree = new THREE.Vector3(); this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x; this.offset = Math.random() * 100; this.speed = 0.5 + Math.random();
                if (mesh.material && mesh.material.emissive) { this.baseEmissive = mesh.material.emissive.clone(); this.hasEmissive = true; }
                this.calculatePositions();
            }
 
            calculatePositions() {
                const h = CONFIG.particles.treeHeight; let t = Math.random();
                if (Math.random() > 0.7 && !this.isDust && this.type !== 'PHOTO') {
                    const y = (t * h) - h/2, angle = t * Math.PI * 12, rBase = CONFIG.particles.treeRadius * (1.0 - t);
                    this.posTree.set(Math.cos(angle) * rBase, y, Math.sin(angle) * rBase);
                } else {
                    t = Math.pow(t, 0.8); const y = (t * h) - h/2, angle = Math.random() * Math.PI * 2, r = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t)) * Math.sqrt(Math.random());
                    this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                }
                const rScatter = this.isDust ? (15 + Math.random()*25) : (10 + Math.random()*15);
                const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi));
            }
 
            update(dt, time, mode, focusTargetMesh, invMatrix) {
                let target, s = this.baseScale, lerpSpeed = 3.0;
                if (mode === 'SCATTER') { _targetVec.copy(this.posScatter).multiplyScalar(STATE.scatterScale); target = _targetVec; }
                else if (mode === 'LETTER') target = this.posScatter;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh && invMatrix) {
                        _targetVec.set(0, 0, CONFIG.camera.z - 15).applyMatrix4(invMatrix); target = _targetVec; lerpSpeed = 6.0; this.mesh.lookAt(camera.position); s = this.baseScale * 5.0;
                    } else { target = this.posScatter; s = 0.01; }
                } else { target = this.posTree; }
                _tempVec.copy(target);
                if(mode === 'TREE') { 
                    const floatScale = (STATE.currentThemeIndex === 1) ? 0.3 : 0.15;
                    _tempVec.y += Math.sin(time * this.speed + this.offset) * floatScale; 
                    _tempVec.x += Math.cos(time * 0.5 * this.speed + this.offset) * 0.1; 
                }
                this.mesh.position.lerp(_tempVec, lerpSpeed * dt);
                if (this.hasEmissive && mode === 'TREE' && !this.isDust) {
                    const blink = Math.sin(time * 2 + this.offset);
                    const maxEmit = (STATE.currentThemeIndex === 1) ? 3.0 : 2.5;
                    this.mesh.material.emissiveIntensity = blink > 0.5 ? (1.0 + (blink - 0.5) * maxEmit) : 0.4;
                }
                if (mode !== 'FOCUS') {
                    if (this.isDust) s = this.baseScale * (0.5 + 0.5 * Math.sin(time * 3 + this.offset));
                    else if ((mode === 'SCATTER' || mode === 'LETTER') && this.type === 'PHOTO') s = this.baseScale * 2.5;
                    if (STATE.currentThemeIndex === 1 && mode === 'TREE' && !this.isDust && this.type !== 'PHOTO') { s *= (1.0 + 0.2 * Math.sin(time * 3 + this.offset)); }
                }
                this.mesh.scale.lerp(_tempVec.set(s,s,s), 5*dt);
            }
        }
 
        class Firework {
            constructor() {
                this.mesh = new THREE.Points(
                    new THREE.BufferGeometry(),
                    new THREE.PointsMaterial({ size: 2.5, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, map: snowTexture, transparent: true })
                );
                this.active = false; this.life = 0; mainGroup.add(this.mesh);
            }
            explode(pos, colorHex) {
                this.active = true; this.life = 1.0; const count = 150;
                const posArr = new Float32Array(count*3), velArr = new Float32Array(count*3), colArr = new Float32Array(count*3);
                const c = new THREE.Color(colorHex);
                for(let i=0; i<count; i++) {
                    posArr[i*3] = pos.x; posArr[i*3+1] = pos.y; posArr[i*3+2] = pos.z;
                    const v = (Math.random()*0.5 + 0.5) * 40; const th = Math.random()*Math.PI*2, ph = Math.random()*Math.PI;
                    velArr[i*3] = v*Math.sin(ph)*Math.cos(th); velArr[i*3+1] = v*Math.sin(ph)*Math.sin(th); velArr[i*3+2] = v*Math.cos(ph);
                    colArr[i*3] = c.r + (Math.random()-0.5)*0.2; colArr[i*3+1] = c.g + (Math.random()-0.5)*0.2; colArr[i*3+2] = c.b;
                }
                this.mesh.geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
                this.mesh.geometry.setAttribute('velocity', new THREE.BufferAttribute(velArr, 3));
                this.mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
                this.mesh.visible = true;
            }
            update(dt) {
                if(!this.active) return;
                this.life -= dt * 0.8;
                if(this.life <= 0) { this.active = false; this.mesh.visible = false; return; }
                const pos = this.mesh.geometry.attributes.position.array, vel = this.mesh.geometry.attributes.velocity.array;
                for(let i=0; i<pos.length/3; i++) {
                    pos[i*3] += vel[i*3] * dt; pos[i*3+1] += vel[i*3+1] * dt; pos[i*3+2] += vel[i*3+2] * dt;
                    vel[i*3+1] -= 20 * dt; vel[i*3] *= 0.95; vel[i*3+1] *= 0.95; vel[i*3+2] *= 0.95;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true; this.mesh.material.opacity = this.life;
            }
        }

        function triggerFireworks(count = 3) {
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    const fw = new Firework(); STATE.fireworks.push(fw);
                    const x = (Math.random()-0.5)*40, y = Math.random()*20 + 10, z = (Math.random()-0.5)*20;
                    const colors = [0xffd700, 0xff0044, 0x00ffff, 0xff69b4];
                    fw.explode(new THREE.Vector3(x,y,z), colors[Math.floor(Math.random()*colors.length)]);
                }, i * 300);
            }
        }

        function createGalaxyBackground() {
            const geometry = new THREE.BufferGeometry(), count = 3000;
            const pos = new Float32Array(count * 3), sizes = new Float32Array(count), colors = new Float32Array(count * 3);
            const c1 = new THREE.Color(0x88aaff), c2 = new THREE.Color(0xffffee), c3 = new THREE.Color(0xffd700);
            for(let i=0; i<count; i++) {
                const r = 60 + Math.random()*250, theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
                pos[i*3] = r*Math.sin(phi)*Math.cos(theta); pos[i*3+1] = r*Math.sin(phi)*Math.sin(theta); pos[i*3+2] = r*Math.cos(phi);
                sizes[i] = Math.random()*2.0; let c = Math.random(), finalC = c<0.6?c2:(c<0.9?c1:c3);
                colors[i*3]=finalC.r; colors[i*3+1]=finalC.g; colors[i*3+2]=finalC.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            galaxySystem = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 1.0, transparent: true, opacity: 0.8, vertexColors: true, sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false }));
            bgGroup.add(galaxySystem);
        }
 
        function createSnowBackground() {
            const geometry = new THREE.BufferGeometry(); const count = CONFIG.particles.snowCount;
            const pos = new Float32Array(count * 3), velocities = new Float32Array(count); 
            for(let i=0; i<count; i++) {
                pos[i*3] = (Math.random() - 0.5) * 100; pos[i*3+1] = (Math.random() - 0.5) * 100; pos[i*3+2] = (Math.random() - 0.5) * 60; velocities[i] = 1.0 + Math.random(); 
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
            snowSystem = new THREE.Points(geometry, matLib.snowFlake); snowSystem.visible = false; bgGroup.add(snowSystem);
        }
 
        function createHeartBackground() {
            const geometry = new THREE.BufferGeometry(); const count = 1500;
            const pos = new Float32Array(count * 3), velocities = new Float32Array(count), colors = new Float32Array(count * 3);
            const c1 = new THREE.Color(CONFIG.colors.barbieHot), c2 = new THREE.Color(CONFIG.colors.barbieSoft), c3 = new THREE.Color(0xffffff);
            for(let i=0; i<count; i++) {
                pos[i*3] = (Math.random() - 0.5) * 120; pos[i*3+1] = (Math.random() - 0.5) * 120; pos[i*3+2] = (Math.random() - 0.5) * 80; velocities[i] = 0.5 + Math.random() * 0.8; 
                let c = Math.random(); let finalC = c < 0.4 ? c1 : (c < 0.7 ? c2 : c3); colors[i*3] = finalC.r; colors[i*3+1] = finalC.g; colors[i*3+2] = finalC.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1)); geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = matLib.heartFlake.clone(); mat.vertexColors = true; heartSystem = new THREE.Points(geometry, mat); heartSystem.visible = false; bgGroup.add(heartSystem);
        }
 
        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16), boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0,-0.5,0), new THREE.Vector3(0,0.3,0), new THREE.Vector3(0.1,0.5,0), new THREE.Vector3(0.3,0.4,0)]);
            const candyGeo = new THREE.TubeGeometry(curve, 8, 0.08, 6, false), dustGeo = new THREE.OctahedronGeometry(0.1, 0);
 
            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random(); let mesh, type;
                if (rand < 0.35) { mesh = new THREE.Mesh(boxGeo, matLib.green); type = 'BOX'; } 
                else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, matLib.gold); type = 'GOLD_BOX'; } 
                else if (rand < 0.90) { mesh = new THREE.Mesh(sphereGeo, matLib.gold); type = 'GOLD_SPHERE'; } 
                else if (rand < 0.96) { mesh = new THREE.Mesh(sphereGeo, matLib.red); type = 'RED'; } 
                else { mesh = new THREE.Mesh(candyGeo, matLib.candy); type = 'CANE'; }
                const s = 0.4 + Math.random() * 0.4; mesh.scale.set(s,s,s); mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                mainGroup.add(mesh); particleSystem.push(new Particle(mesh, type, false));
            }
            for(let i=0; i<CONFIG.particles.dustCount; i++) {
                const mesh = new THREE.Mesh(dustGeo, matLib.dust); mesh.scale.setScalar(0.5 + Math.random()); mainGroup.add(mesh); particleSystem.push(new Particle(mesh, 'DUST', true));
            }
            createStarTopper();
        }
 
        function createStarTopper() {
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), matLib.starGold);
            star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
            // Replace external image with generated glow texture
            const halo = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), new THREE.MeshBasicMaterial({ 
                map: glowTexture, 
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.5, color: 0xffaa00 
            }));
            star.add(halo); starGroup.add(star); STATE.starMesh = star; STATE.starHaloMesh = halo; 
        }
 
        function switchTheme(themeIndex) {
            STATE.currentThemeIndex = themeIndex; triggerFireworks(5);
            const titleEl = document.getElementById('main-title');
            if (titleEl) {
                if (themeIndex === 0) { 
                    titleEl.style.color = '#d4af37'; 
                    titleEl.style.textShadow = '0 0 15px rgba(212, 175, 55, 0.4), 0 0 30px rgba(212, 175, 55, 0.2)'; 
                    titleEl.style.backgroundImage = 'linear-gradient(180deg, #fffdf0 0%, #eacda3 30%, #d6ae7b 60%, #8b6c42 100%)';
                } else if (themeIndex === 1) { 
                    titleEl.style.color = '#e0ffff'; 
                    titleEl.style.textShadow = '0 0 15px rgba(0, 255, 255, 0.6), 0 0 30px rgba(0, 255, 255, 0.4), 0 0 45px rgba(170, 221, 255, 0.3)'; 
                    titleEl.style.backgroundImage = 'linear-gradient(180deg, #e0ffff 0%, #b4e1f3 30%, #87ceeb 60%, #4682b4 100%)';
                } else if (themeIndex === 2) {
                    titleEl.style.color = '#ff1694';
                    titleEl.style.textShadow = '0 0 15px rgba(255, 22, 148, 0.6), 0 0 30px rgba(255, 183, 197, 0.4)';
                    titleEl.style.backgroundImage = 'linear-gradient(180deg, #ffb7c5 0%, #ff69b4 30%, #ff1694 60%, #c71585 100%)';
                }
            }
            
            // 更新主题材质
            updateThemeMaterials(themeIndex);
            
            // 更新背景效果
            updateBackgroundEffects(themeIndex);
        }
        
        function updateThemeMaterials(themeIndex) {
            // 重置所有粒子材质
            particleSystem.forEach(particle => {
                if (particle.isDust) return;
                
                switch(themeIndex) {
                    case 0: // 金色主题
                        if (particle.type === 'BOX') particle.mesh.material = matLib.green;
                        else if (particle.type === 'GOLD_BOX' || particle.type === 'GOLD_SPHERE') particle.mesh.material = matLib.gold;
                        else if (particle.type === 'RED') particle.mesh.material = matLib.red;
                        else if (particle.type === 'CANE') particle.mesh.material = matLib.candy;
                        break;
                        
                    case 1: // 冰雪主题
                        if (particle.type === 'BOX') particle.mesh.material = matLib.ice;
                        else if (particle.type === 'GOLD_BOX' || particle.type === 'GOLD_SPHERE') particle.mesh.material = matLib.frozenCyan;
                        else if (particle.type === 'RED') particle.mesh.material = matLib.frozenMagenta;
                        else if (particle.type === 'CANE') particle.mesh.material = matLib.snow;
                        break;
                        
                    case 2: // 芭比主题
                        if (particle.type === 'BOX') particle.mesh.material = matLib.barbieSoft;
                        else if (particle.type === 'GOLD_BOX' || particle.type === 'GOLD_SPHERE') particle.mesh.material = matLib.barbieMain;
                        else if (particle.type === 'RED') particle.mesh.material = matLib.barbieMain;
                        else if (particle.type === 'CANE') particle.mesh.material = matLib.pearl;
                        break;
                }
            });
            
            // 更新星星材质
            if (themeIndex === 0) {
                STATE.starMesh.material = matLib.starGold;
                STATE.starHaloMesh.material.color.set(0xffaa00);
            } else if (themeIndex === 1) {
                STATE.starMesh.material = matLib.starIce;
                STATE.starHaloMesh.material.color.set(0x00ffff);
            } else if (themeIndex === 2) {
                STATE.starMesh.material = matLib.starBarbie;
                STATE.starHaloMesh.material.color.set(0xff0088);
            }
        }
        
        function updateBackgroundEffects(themeIndex) {
            // 重置所有背景效果
            snowSystem.visible = false;
            heartSystem.visible = false;
            
            // 根据主题显示不同背景效果
            if (themeIndex === 1) {
                snowSystem.visible = true;
            } else if (themeIndex === 2) {
                heartSystem.visible = true;
            }
        }

        function setupEvents() {
            // 主题切换按钮
            document.getElementById('btn-switch-theme').addEventListener('click', () => {
                const nextTheme = (STATE.currentThemeIndex + 1) % 3;
                switchTheme(nextTheme);
            });
            
            // 全屏按钮
            document.getElementById('btn-fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        showToast(`全屏请求失败: ${err.message}`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            });
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
            
            // 上传照片按钮
            document.getElementById('btn-add-photo').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });
            
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            
            // 书信相关按钮
            document.getElementById('btn-write-letter').addEventListener('click', () => {
                document.getElementById('letter-editor-modal').style.display = 'flex';
                document.getElementById('letter-text-input').value = STATE.letterContent;
            });
            
            document.getElementById('btn-cancel-letter').addEventListener('click', () => {
                document.getElementById('letter-editor-modal').style.display = 'none';
            });
            
            document.getElementById('btn-save-letter').addEventListener('click', () => {
                STATE.letterContent = document.getElementById('letter-text-input').value;
                document.getElementById('letter-editor-modal').style.display = 'none';
                showToast('书信已保存');
            });
            
            document.getElementById('btn-close-letter-mode').addEventListener('click', exitLetterMode);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (!file.type.startsWith('image/')) continue;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    addPhotoToScene(e.target.result);
                };
                reader.readAsDataURL(file);
            }
            
            // 清空输入，允许重复上传同一文件
            event.target.value = '';
        }
        
        function addPhotoToScene(imageUrl) {
            const loader = new THREE.TextureLoader();
            loader.load(imageUrl, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                
                // 创建照片平面
                const aspect = texture.image.width / texture.image.height;
                const size = 2.5;
                const geometry = new THREE.PlaneGeometry(aspect * size, size);
                
                // 创建相框
                const frameGeometry = new THREE.BoxGeometry(aspect * size + 0.3, size + 0.3, 0.2);
                
                // 根据当前主题选择相框材质
                let frameMaterial;
                if (STATE.currentThemeIndex === 0) frameMaterial = matLib.frameGold;
                else if (STATE.currentThemeIndex === 1) frameMaterial = matLib.frameIce;
                else frameMaterial = matLib.frameBarbie;
                
                // 创建照片组合
                const photoGroup = new THREE.Group();
                const frameMesh = new THREE.Mesh(frameGeometry, frameMaterial);
                frameMesh.position.z = -0.1;
                const photoMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture }));
                
                photoGroup.add(frameMesh);
                photoGroup.add(photoMesh);
                photoMeshGroup.add(photoGroup);
                
                // 添加到粒子系统
                const particle = new Particle(photoGroup, 'PHOTO');
                particleSystem.push(particle);
                
                showToast('照片已添加');
            });
        }
        
        function setupLetterSystem() {
            // 初始化打字机效果
            STATE.letterTyper = {
                text: '',
                current: 0,
                speed: 50,
                interval: null,
                done: false
            };
        }
        
        function enterLetterMode() {
            STATE.mode = 'LETTER';
            const overlay = document.getElementById('letter-overlay');
            overlay.style.display = 'flex';
            
            // 淡入效果
            setTimeout(() => {
                overlay.style.opacity = 1;
                document.querySelector('.letter-paper').style.transform = 'translateY(0)';
            }, 10);
            
            // 启动打字效果
            startLetterTyping();
        }
        
        function exitLetterMode() {
            const overlay = document.getElementById('letter-overlay');
            overlay.style.opacity = 0;
            document.querySelector('.letter-paper').style.transform = 'translateY(20px)';
            
            // 淡出效果后隐藏
            setTimeout(() => {
                overlay.style.display = 'none';
                STATE.mode = 'TREE';
                stopLetterTyping();
            }, 1500);
        }
        
        function startLetterTyping() {
            stopLetterTyping();
            const display = document.getElementById('letter-content-display');
            display.innerHTML = '';
            STATE.letterTyper.text = STATE.letterContent || '请先撰写你的书信内容...';
            STATE.letterTyper.current = 0;
            STATE.letterTyper.done = false;
            
            STATE.letterTyper.interval = setInterval(() => {
                if (STATE.letterTyper.current < STATE.letterTyper.text.length) {
                    display.textContent += STATE.letterTyper.text[STATE.letterTyper.current];
                    STATE.letterTyper.current++;
                    // 自动滚动到底部
                    display.scrollTop = display.scrollHeight;
                } else {
                    stopLetterTyping();
                    STATE.letterTyper.done = true;
                }
            }, STATE.letterTyper.speed);
        }
        
        function stopLetterTyping() {
            if (STATE.letterTyper.interval) {
                clearInterval(STATE.letterTyper.interval);
                STATE.letterTyper.interval = null;
            }
        }
        
        function setupMouseInteraction() {
            let prevMouseX = 0, prevMouseY = 0;
            
            // 鼠标按下
            renderer.domElement.addEventListener('mousedown', (e) => {
                STATE.mouse.isDragging = true;
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
            
            // 鼠标移动
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (STATE.mouse.isDragging) {
                    const deltaX = e.clientX - prevMouseX;
                    const deltaY = e.clientY - prevMouseY;
                    
                    STATE.rotation.y += deltaX * 0.005;
                    STATE.rotation.x += deltaY * 0.005;
                    STATE.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, STATE.rotation.x));
                    
                    prevMouseX = e.clientX;
                    prevMouseY = e.clientY;
                }
            });
            
            // 鼠标释放
            window.addEventListener('mouseup', () => {
                STATE.mouse.isDragging = false;
            });
            
            // 鼠标滚轮
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    // 滚轮上滚 - 聚集
                    STATE.mouse.targetScatter = Math.max(1.0, STATE.mouse.targetScatter - 0.2);
                    if (STATE.mode === 'SCATTER' && STATE.mouse.targetScatter === 1.0) {
                        STATE.mode = 'TREE';
                    }
                } else {
                    // 滚轮下滚 - 散开
                    STATE.mode = 'SCATTER';
                    STATE.mouse.targetScatter = Math.min(3.0, STATE.mouse.targetScatter + 0.2);
                }
            });
            
            // 触摸设备支持
            setupTouchEvents();
        }
        
        function setupTouchEvents() {
            const canvas = renderer.domElement;
            let touchStartX, touchStartY;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    STATE.mouse.isDragging = true;
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (STATE.mouse.isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;
                    
                    STATE.rotation.y += deltaX * 0.005;
                    STATE.rotation.x += deltaY * 0.005;
                    STATE.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, STATE.rotation.x));
                    
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
                e.preventDefault();
            });
            
            canvas.addEventListener('touchend', () => {
                STATE.mouse.isDragging = false;
            });
        }
        
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            // 设置摄像头
            video = document.getElementById("webcam");
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 480, height: 360 }
            });
            video.srcObject = stream;
            
            const canvasElement = document.getElementById("webcam-preview");
            canvasCtx = canvasElement.getContext("2d");
            drawingUtils = new DrawingUtils(canvasCtx);
            
            // 调整预览大小
            canvasElement.width = 480;
            canvasElement.height = 360;
            
            // 显示摄像头预览
            setTimeout(() => {
                document.getElementById('webcam-wrapper').style.opacity = 1;
                document.getElementById('gesture-hud').style.opacity = 1;
            }, 1000);
            
            // 开始处理视频
            video.play().then(() => {
                setTimeout(processVideo, 100);
            });
        }
        
        function processVideo() {
            if (!handLandmarker || !video || video.paused) {
                requestAnimationFrame(processVideo);
                return;
            }
            
            const results = handLandmarker.detectForVideo(video, performance.now());
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);
            
            if (results.handedness.length > 0) {
                document.getElementById('hud-status').textContent = '已检测到手';
                STATE.hand.detected = true;
                
                // 绘制手部关键点
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawLandmarks(landmarks, { color: "#d4af37", lineWidth: 2 });
                    drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#aaaaaa", lineWidth: 1 });
                    
                    // 计算手掌中心
                    const palmCenter = calculatePalmCenter(landmarks);
                    STATE.palmCenter.x = palmCenter.x / canvasCtx.canvas.width;
                    STATE.palmCenter.y = palmCenter.y / canvasCtx.canvas.height;
                    STATE.hasPalmCenter = true;
                    
                    // 检测手势
                    detectGestures(landmarks);
                }
            } else {
                document.getElementById('hud-status').textContent = '未检测到手';
                document.getElementById('hud-action').textContent = '-';
                STATE.hand.detected = false;
                STATE.hasPalmCenter = false;
            }
            
            canvasCtx.restore();
            requestAnimationFrame(processVideo);
        }
        
        function calculatePalmCenter(landmarks) {
            // 取手掌几个关键点的平均值作为中心
            const palmIndices = [0, 1, 5, 9, 13, 17];
            let x = 0, y = 0;
            
            for (const idx of palmIndices) {
                x += landmarks[idx].x * canvasCtx.canvas.width;
                y += landmarks[idx].y * canvasCtx.canvas.height;
            }
            
            return { x: x / palmIndices.length, y: y / palmIndices.length };
        }
        
        function detectGestures(landmarks) {
            // 检测手掌是否张开
            const thumbOpen = isFingerOpen(landmarks, 4, 3, 2, 1, 0);
            const indexOpen = isFingerOpen(landmarks, 8, 7, 6, 5, 0);
            const middleOpen = isFingerOpen(landmarks, 12, 11, 10, 9, 0);
            const ringOpen = isFingerOpen(landmarks, 16, 15, 14, 13, 0);
            const pinkyOpen = isFingerOpen(landmarks, 20, 19, 18, 17, 0);
            
            const fingersOpen = [thumbOpen, indexOpen, middleOpen, ringOpen, pinkyOpen];
            const openCount = fingersOpen.filter(open => open).length;
            
            // 手势判断
            let gesture = '-';
            if (openCount === 5) {
                gesture = '手掌张开';
                handleOpenPalmGesture();
            } else if (indexOpen && !middleOpen && !ringOpen && !pinkyOpen) {
                gesture = '指向';
                handlePointingGesture(landmarks[8]);
            } else if (!indexOpen && !middleOpen && !ringOpen && !pinkyOpen && thumbOpen) {
                gesture = '点赞';
                triggerFireworks(2);
            }
            
            document.getElementById('hud-action').textContent = gesture;
        }
        
        function isFingerOpen(landmarks, tipIdx, dipIdx, pipIdx, mcpIdx, palmIdx) {
            const tip = landmarks[tipIdx];
            const dip = landmarks[dipIdx];
            const pip = landmarks[pipIdx];
            const mcp = landmarks[mcpIdx];
            const palm = landmarks[palmIdx];
            
            // 计算指尖到指根的距离
            const tipToMcp = distance(tip, mcp);
            // 计算指节到指根的距离
            const pipToMcp = distance(pip, mcp);
            
            // 如果指尖到指根的距离远大于指节到指根的距离，则认为手指张开
            return tipToMcp > pipToMcp * 1.5;
        }
        
        function distance(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }
        
        function handleOpenPalmGesture() {
            // 防抖处理
            const now = Date.now();
            if (now - STATE.gestureDebounceTimer < 1000) return;
            STATE.gestureDebounceTimer = now;
            
            // 切换模式
            if (STATE.mode === 'TREE') {
                STATE.mode = 'SCATTER';
                STATE.mouse.targetScatter = 2.0;
            } else if (STATE.mode === 'SCATTER') {
                STATE.mode = 'TREE';
            }
        }
        
        function handlePointingGesture(indexTip) {
            // 计算 normalized 坐标 (-1 到 1)
            const x = (indexTip.x * 2 - 1) * CONFIG.gestures.sensitivity;
            const y = (indexTip.y * -2 + 1) * CONFIG.gestures.sensitivity;
            
            // 应用旋转
            STATE.rotation.y = x;
            STATE.rotation.x = y;
            STATE.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, STATE.rotation.x));
        }
 
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            STATE.time += dt;
            
            // 更新旋转
            mainGroup.rotation.x = STATE.rotation.x;
            mainGroup.rotation.y = STATE.rotation.y;
            
            // 更新散点比例
            STATE.scatterScale += (STATE.mouse.targetScatter - STATE.scatterScale) * 5 * dt;
            
            // 更新粒子
            const invMatrix = _invMatrix.copy(mainGroup.matrixWorld).invert();
            particleSystem.forEach(particle => {
                particle.update(dt, STATE.time, STATE.mode, STATE.focusTarget, invMatrix);
            });
            
            // 更新背景效果
            updateBackgrounds(dt);
            
            // 更新烟花
            STATE.fireworks.forEach(fw => fw.update(dt));
            // 移除已结束的烟花
            STATE.fireworks = STATE.fireworks.filter(fw => fw.active);
            
            // 渲染
            composer.render(scene, camera);
        }
        
        function updateBackgrounds(dt) {
            // 更新雪花
            if (snowSystem.visible) {
                const positions = snowSystem.geometry.attributes.position.array;
                const velocities = snowSystem.geometry.attributes.velocity.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // 下落
                    positions[i + 1] -= velocities[i / 3] * dt * CONFIG.particles.snowSpeed * 0.1;
                    
                    // 超出边界重置
                    if (positions[i + 1] < -50) {
                        positions[i] = (Math.random() - 0.5) * 100;
                        positions[i + 1] = 50;
                        positions[i + 2] = (Math.random() - 0.5) * 60;
                    }
                }
                
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // 更新爱心
            if (heartSystem.visible) {
                const positions = heartSystem.geometry.attributes.position.array;
                const velocities = heartSystem.geometry.attributes.velocity.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // 上升
                    positions[i + 1] += velocities[i / 3] * dt * 5;
                    
                    // 超出边界重置
                    if (positions[i + 1] > 60) {
                        positions[i] = (Math.random() - 0.5) * 120;
                        positions[i + 1] = -60;
                        positions[i + 2] = (Math.random() - 0.5) * 80;
                    }
                }
                
                heartSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // 旋转星系背景
            galaxySystem.rotation.y += dt * 0.001;
        }
 
        // 初始化应用
        window.addEventListener('load', init);
    </script>
</body>
</html>
